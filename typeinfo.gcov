        -:    0:Source:/usr/include/c++/4.7/typeinfo
        -:    0:Graph:TestDeque.gcno
        -:    0:Data:TestDeque.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:// RTTI support for -*- C++ -*-
        -:    2:// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
        -:    3:// 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011, 2012
        -:    4:// Free Software Foundation
        -:    5://
        -:    6:// This file is part of GCC.
        -:    7://
        -:    8:// GCC is free software; you can redistribute it and/or modify
        -:    9:// it under the terms of the GNU General Public License as published by
        -:   10:// the Free Software Foundation; either version 3, or (at your option)
        -:   11:// any later version.
        -:   12://
        -:   13:// GCC is distributed in the hope that it will be useful,
        -:   14:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:// GNU General Public License for more details.
        -:   17://
        -:   18:// Under Section 7 of GPL version 3, you are granted additional
        -:   19:// permissions described in the GCC Runtime Library Exception, version
        -:   20:// 3.1, as published by the Free Software Foundation.
        -:   21:
        -:   22:// You should have received a copy of the GNU General Public License and
        -:   23:// a copy of the GCC Runtime Library Exception along with this program;
        -:   24:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   25:// <http://www.gnu.org/licenses/>.
        -:   26:
        -:   27:/** @file typeinfo
        -:   28: *  This is a Standard C++ Library header.
        -:   29: */
        -:   30:
        -:   31:#ifndef _TYPEINFO
        -:   32:#define _TYPEINFO
        -:   33:
        -:   34:#pragma GCC system_header
        -:   35:
        -:   36:#include <exception>
        -:   37:#ifdef __GXX_EXPERIMENTAL_CXX0X__
        -:   38:#include <bits/hash_bytes.h>
        -:   39:#endif
        -:   40:
        -:   41:#pragma GCC visibility push(default)
        -:   42:
        -:   43:extern "C++" {
        -:   44:
        -:   45:namespace __cxxabiv1
        -:   46:{
        -:   47:  class __class_type_info;
        -:   48:} // namespace __cxxabiv1
        -:   49:
        -:   50:// Determine whether typeinfo names for the same type are merged (in which
        -:   51:// case comparison can just compare pointers) or not (in which case strings
        -:   52:// must be compared), and whether comparison is to be implemented inline or
        -:   53:// not.  We used to do inline pointer comparison by default if weak symbols
        -:   54:// are available, but even with weak symbols sometimes names are not merged
        -:   55:// when objects are loaded with RTLD_LOCAL, so now we always use strcmp by
        -:   56:// default.  For ABI compatibility, we do the strcmp inline if weak symbols
        -:   57:// are available, and out-of-line if not.  Out-of-line pointer comparison
        -:   58:// is used where the object files are to be portable to multiple systems,
        -:   59:// some of which may not be able to use pointer comparison, but the
        -:   60:// particular system for which libstdc++ is being built can use pointer
        -:   61:// comparison; in particular for most ARM EABI systems, where the ABI
        -:   62:// specifies out-of-line comparison.  The compiler's target configuration
        -:   63:// can override the defaults by defining __GXX_TYPEINFO_EQUALITY_INLINE to
        -:   64:// 1 or 0 to indicate whether or not comparison is inline, and
        -:   65:// __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to indicate whether or not pointer
        -:   66:// comparison can be used.
        -:   67:
        -:   68:#ifndef __GXX_MERGED_TYPEINFO_NAMES
        -:   69:// By default, typeinfo names are not merged.
        -:   70:#define __GXX_MERGED_TYPEINFO_NAMES 0
        -:   71:#endif
        -:   72:
        -:   73:// By default follow the old inline rules to avoid ABI changes.
        -:   74:#ifndef __GXX_TYPEINFO_EQUALITY_INLINE
        -:   75:  #if !__GXX_WEAK__
        -:   76:    #define __GXX_TYPEINFO_EQUALITY_INLINE 0
        -:   77:  #else
        -:   78:    #define __GXX_TYPEINFO_EQUALITY_INLINE 1
        -:   79:  #endif
        -:   80:#endif
        -:   81:
        -:   82:namespace std
        -:   83:{
        -:   84:  /**
        -:   85:   *  @brief  Part of RTTI.
        -:   86:   *
        -:   87:   *  The @c type_info class describes type information generated by
        -:   88:   *  an implementation.
        -:   89:  */
        -:   90:  class type_info
        -:   91:  {
        -:   92:  public:
        -:   93:    /** Destructor first. Being the first non-inline virtual function, this
        -:   94:     *  controls in which translation unit the vtable is emitted. The
        -:   95:     *  compiler makes use of that information to know where to emit
        -:   96:     *  the runtime-mandated type_info structures in the new-abi.  */
        -:   97:    virtual ~type_info();
        -:   98:
        -:   99:    /** Returns an @e implementation-defined byte string; this is not
        -:  100:     *  portable between compilers!  */
function _ZNKSt9type_info4nameEv called 1620 returned 100% blocks executed 80%
     1620:  101:    const char* name() const
     1620:  102:    { return __name[0] == '*' ? __name + 1 : __name; }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  103:
        -:  104:#if !__GXX_TYPEINFO_EQUALITY_INLINE
        -:  105:    // In old abi, or when weak symbols are not supported, there can
        -:  106:    // be multiple instances of a type_info object for one
        -:  107:    // type. Uniqueness must use the _name value, not object address.
        -:  108:    bool before(const type_info& __arg) const;
        -:  109:    bool operator==(const type_info& __arg) const;
        -:  110:#else
        -:  111:  #if !__GXX_MERGED_TYPEINFO_NAMES
        -:  112:    /** Returns true if @c *this precedes @c __arg in the implementation's
        -:  113:     *  collation order.  */
        -:  114:    // Even with the new abi, on systems that support dlopen
        -:  115:    // we can run into cases where type_info names aren't merged,
        -:  116:    // so we still need to do string comparison.
        -:  117:    bool before(const type_info& __arg) const
        -:  118:    { return (__name[0] == '*' && __arg.__name[0] == '*')
        -:  119:	? __name < __arg.__name
        -:  120:	: __builtin_strcmp (__name, __arg.__name) < 0; }
        -:  121:
function _ZNKSt9type_infoeqERKS_ called 0 returned 0% blocks executed 0%
    #####:  122:    bool operator==(const type_info& __arg) const
        -:  123:    {
        -:  124:      return ((__name == __arg.__name)
    #####:  125:	      || (__name[0] != '*' &&
    #####:  126:		  __builtin_strcmp (__name, __arg.__name) == 0));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  127:    }
        -:  128:  #else
        -:  129:    // On some targets we can rely on type_info's NTBS being unique,
        -:  130:    // and therefore address comparisons are sufficient.
        -:  131:    bool before(const type_info& __arg) const
        -:  132:    { return __name < __arg.__name; }
        -:  133:
        -:  134:    bool operator==(const type_info& __arg) const
        -:  135:    { return __name == __arg.__name; }
        -:  136:  #endif
        -:  137:#endif
        -:  138:    bool operator!=(const type_info& __arg) const
        -:  139:    { return !operator==(__arg); }
        -:  140:
        -:  141:#ifdef __GXX_EXPERIMENTAL_CXX0X__
        -:  142:    size_t hash_code() const noexcept
        -:  143:    {
        -:  144:#  if !__GXX_MERGED_TYPEINFO_NAMES
        -:  145:      return _Hash_bytes(name(), __builtin_strlen(name()),
        -:  146:			 static_cast<size_t>(0xc70f6907UL));
        -:  147:#  else
        -:  148:      return reinterpret_cast<size_t>(__name);
        -:  149:#  endif
        -:  150:    }
        -:  151:#endif // __GXX_EXPERIMENTAL_CXX0X__
        -:  152:
        -:  153:    // Return true if this is a pointer type of some kind
        -:  154:    virtual bool __is_pointer_p() const;
        -:  155:
        -:  156:    // Return true if this is a function type
        -:  157:    virtual bool __is_function_p() const;
        -:  158:
        -:  159:    // Try and catch a thrown type. Store an adjusted pointer to the
        -:  160:    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
        -:  161:    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
        -:  162:    // type, then THR_OBJ is the pointer itself. OUTER indicates the
        -:  163:    // number of outer pointers, and whether they were const
        -:  164:    // qualified.
        -:  165:    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
        -:  166:			    unsigned __outer) const;
        -:  167:
        -:  168:    // Internally used during catch matching
        -:  169:    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        -:  170:			     void **__obj_ptr) const;
        -:  171:
        -:  172:  protected:
        -:  173:    const char *__name;
        -:  174:
        -:  175:    explicit type_info(const char *__n): __name(__n) { }
        -:  176:
        -:  177:  private:
        -:  178:    /// Assigning type_info is not supported.
        -:  179:    type_info& operator=(const type_info&);
        -:  180:    type_info(const type_info&);
        -:  181:  };
        -:  182:
        -:  183:  /**
        -:  184:   *  @brief  Thrown during incorrect typecasting.
        -:  185:   *  @ingroup exceptions
        -:  186:   *
        -:  187:   *  If you attempt an invalid @c dynamic_cast expression, an instance of
        -:  188:   *  this class (or something derived from this class) is thrown.  */
        -:  189:  class bad_cast : public exception
        -:  190:  {
        -:  191:  public:
        -:  192:    bad_cast() _GLIBCXX_USE_NOEXCEPT { }
        -:  193:
        -:  194:    // This declaration is not useless:
        -:  195:    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
        -:  196:    virtual ~bad_cast() _GLIBCXX_USE_NOEXCEPT;
        -:  197:
        -:  198:    // See comment in eh_exception.cc.
        -:  199:    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
        -:  200:  };
        -:  201:
        -:  202:  /**
        -:  203:   *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
        -:  204:   *  @ingroup exceptions
        -:  205:   */
        -:  206:  class bad_typeid : public exception
        -:  207:  {
        -:  208:  public:
        -:  209:    bad_typeid () _GLIBCXX_USE_NOEXCEPT { }
        -:  210:
        -:  211:    // This declaration is not useless:
        -:  212:    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
        -:  213:    virtual ~bad_typeid() _GLIBCXX_USE_NOEXCEPT;
        -:  214:
        -:  215:    // See comment in eh_exception.cc.
        -:  216:    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
        -:  217:  };
        -:  218:} // namespace std
        -:  219:
        -:  220:} // extern "C++"
        -:  221:
        -:  222:#pragma GCC visibility pop
        -:  223:
        -:  224:#endif
